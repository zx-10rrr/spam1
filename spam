pgm1
package test;

import java.util.Scanner;

public class p8 {
    int d[];
    int num_ver; // This variable represents the number of vertices in the graph
    static int max_value = 999; // A constant representing a large value for infinity

    // Constructor for the class, initializes the number of vertices and an array for distances
    public p8(int num_ver) {
        this.num_ver = num_ver; // Initializing num_ver with the provided number of vertices
        d = new int[num_ver + 1]; // Creating an array to store distances for each vertex
    }

    // Method to perform Bellman-Ford algorithm for finding shortest paths from a source vertex
    public void bellmanfordevaluation(int source, int a[][]) {
        // Initializing distances array with maximum values
        for (int node = 1; node <= num_ver; node++)
            d[node] = max_value;
        d[source] = 0; // Distance from the source vertex to itself is set to 0

        // Iterating over vertices to update distances based on edges
        for (int node = 1; node <= num_ver - 1; node++)
            for (int sn = 1; sn <= num_ver; sn++)
                for (int dn = 1; dn <= num_ver; dn++)
                    if (a[sn][dn] != max_value)
                        if (d[dn] > d[sn] + a[sn][dn])
                            d[dn] = d[sn] + a[sn][dn];

        // Checking for negative edge cycles
        for (int sn = 1; sn <= num_ver; sn++)
            for (int dn = 1; dn <= num_ver; dn++)
                if (a[sn][dn] != max_value)
                    if (d[dn] > d[sn] + a[sn][dn])
                        System.out.println("The graph contains a negative edge cycle");

        // Displaying the distances from the source vertex to each vertex
        for (int vertex = 1; vertex <= num_ver; vertex++)
            System.out.println("Distance from source " + source + " to " + vertex + " is " + d[vertex]);
    }

    // Main method where the program starts
    public static void main(String args[]) {
        int num_ver = 0; // Variable to store the number of vertices
        int source; // Variable to store the source vertex
        Scanner scanner = new Scanner(System.in); // Scanner object for user input

        System.out.println("Enter the number of vertices");
        num_ver = scanner.nextInt(); // Taking user input for the number of vertices

        // Creating an adjacency matrix to represent the graph
        int a[][] = new int[num_ver + 1][num_ver + 1];

        System.out.println("Enter the adjacency matrix:");
        // Populating the adjacency matrix with user input, treating 0 as infinity
        for (int sn = 1; sn <= num_ver; sn++)
            for (int dn = 1; dn <= num_ver; dn++) {
                a[sn][dn] = scanner.nextInt();
                if (sn != dn) {
                    if (a[sn][dn] == 0)
                        a[sn][dn] = max_value;
                } else {
                    a[sn][dn] = 0;
                }
            }

        System.out.println("Enter the source vertex");
        source = scanner.nextInt(); // Taking user input for the source vertex

        // Creating an object of the p8 class and performing Bellman-Ford algorithm
        p8 b = new p8(num_ver);
        b.bellmanfordevaluation(source, a);

        scanner.close(); // Closing the scanner to avoid resource leak
    }
}
pgm2
package test;
import java.util.Scanner;

public class p12 {
    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        int bs, outgoing, n, incoming, s = 0;

        System.out.println("Enter the buffer size, outgoing rate, inputs, incoming size:");
        bs = in.nextInt();
        outgoing = in.nextInt();
        n = in.nextInt();
        incoming = in.nextInt();

        while (n != 0) {
            System.out.println("Incoming size is " + incoming);

            if (incoming <= (bs - s)) {
                s = s + incoming;
                System.out.println("Bucket buffer size is " + s + " out of " + bs);
            } else {
                System.out.println("Packet lost=" + (incoming - (bs - s)));
                s = bs;
                System.out.println("Bucket buffer size is " + s + " out of " + bs);
            }

            s -= outgoing;
            System.out.println("After outgoing=" + s + " packet left out of " + bs + " in buffer");

            n--;
            Thread.sleep(3000);
        }

        in.close();
    }
}
pgm3
set ns [new Simulator]
set nf [open prog1.nam w]
set nd [open prog1.tr w]
$ns namtrace-all $nf
$ns trace-all $nd

proc finish {} {
    global ns nf nd
    $ns flush-trace
    close $nf
    close $nd
    exec nam prog1.nam &
    exit 0
}

set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]

$ns duplex-link $n0 $n1 1Mb 10ms DropTail
$ns duplex-link $n1 $n2 512kb 10ms DropTail
$ns queue-limit $n1 $n2 10

set udp0 [new Agent/UDP]
set cbr0 [new Application/Traffic/CBR]
$cbr0 set packetSize_ 500
$cbr0 set interval_ 0.005

$ns attach-agent $n0 $udp0
$cbr0 attach-agent $udp0

set sink [new Agent/Null]
$ns attach-agent $n2 $sink
$ns connect $udp0 $sink

$ns at 0.2 "$cbr0 start"
$ns at 4.5 "$cbr0 stop"
$ns at 5.0 finish

$ns run

pgm5
set ns [new Simulator]
set nf [open prog2.nam w]
$ns namtrace-all $nf
set nd [open prog2.tr w]
$ns trace-all $nd
proc finish {} {
global ns nf nd
$ns flush-trace
close $nf
close $nd
exec nam prog2.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]
set n5 [$ns node]
set n6 [$ns node]
$ns duplex-link $n1 $n0 1Mb 10ms DropTail
$ns duplex-link $n2 $n0 1Mb 10ms DropTail
$ns duplex-link $n3 $n0 1Mb 10ms DropTail
$ns duplex-link $n4 $n0 1Mb 10ms DropTail
$ns duplex-link $n5 $n0 1Mb 10ms DropTail
$ns duplex-link $n6 $n0 1Mb 10ms DropTail
Agent/Ping instproc recv {from rtt} {
$self instvar node_
puts "node [$node_ id] recieved ping answer from \
$from with round-trip-time $rtt ms."
}
set p1 [new Agent/Ping]
set p2 [new Agent/Ping]
set p3 [new Agent/Ping]
set p4 [new Agent/Ping]
set p5 [new Agent/Ping]
set p6 [new Agent/Ping]
$ns attach-agent $n1 $p1
$ns attach-agent $n2 $p2
$ns attach-agent $n3 $p3
$ns attach-agent $n4 $p4
$ns attach-agent $n5 $p5
$ns attach-agent $n6 $p6
$ns queue-limit $n0 $n4 3
$ns queue-limit $n0 $n5 2
$ns queue-limit $n0 $n6 2
$ns queue-limit $n0 $n3 2
$ns queue-limit $n0 $n2 1
$ns queue-limit $n0 $n1 2
$ns connect $p1 $p4
$ns connect $p2 $p5
$ns connect $p3 $p6
$ns connect $p6 $p3
$ns at 0.2 "$p1 send"
$ns at 0.4 "$p2 send"
$ns at 0.6 "$p3 send"
$ns at 1.0 "$p4 send"
$ns at 1.2 "$p5 send"
$ns at 1.4 "$p6 send"
$ns at 2.0 "finish"
$ns run
